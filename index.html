<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Reels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    * {
      box-sizing: border-box;
    }

    /* DM Serif Bold custom untuk judul */
    @font-face {
      font-family: 'DMSerifCustomBold';
      src: url('./fonts/DMSerifDisplay-Bold.ttf') format('truetype');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    /* Plus Jakarta Bold lokal */
    @font-face {
      font-family: 'PlusJakartaCustom';
      src: url('./fonts/PlusJakartaSans-Bold.woff2') format('woff2');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    body {
      margin: 0;
      padding: 12px;
      display: flex;
      gap: 16px;
      background: radial-gradient(circle at top, #020617 0%, #020617 40%, #020617 100%);
      color: #e5e7eb;
      font-family: 'PlusJakartaCustom', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    .panel {
      background: #020617;
      padding: 16px 14px;
      border-radius: 14px;
      border: 1px solid #1f2937;
      box-shadow: 0 16px 40px rgba(0,0,0,0.65);
    }

    .left {
      width: 380px;
      max-width: 100%;
      flex-shrink: 0;
    }

    .right {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 0;
    }

    h2 {
      margin: 0 0 4px 0;
      font-size: 18px;
      letter-spacing: 0.02em;
    }

    small {
      font-size: 11px;
      color: #9ca3af;
      display: block;
      margin-bottom: 6px;
      line-height: 1.4;
    }

    .field {
      margin-top: 10px;
    }

    label {
      font-size: 13px;
      display: block;
      margin-bottom: 4px;
      color: #cbd5f5;
    }

    textarea {
      width: 100%;
      min-height: 56px;
      background: #020617;
      color: #e5e7eb;
      border-radius: 10px;
      border: 1px solid #334155;
      padding: 9px 11px;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      outline: none;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
    }

    #body {
      min-height: 130px;
    }

    textarea::placeholder {
      color: #64748b;
    }

    textarea:hover {
      border-color: #4b5563;
      background: #020819;
    }

    textarea:focus {
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37,99,235,0.8);
      background: #020819;
    }

    .btn-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background-color 0.16s ease, transform 0.08s ease, box-shadow 0.16s ease;
    }

    .btn-primary {
      background: #2563eb;
      color: #fff;
      box-shadow: 0 8px 20px rgba(37,99,235,0.5);
    }

    .btn-primary:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(37,99,235,0.6);
    }

    .btn-secondary {
      background: #111827;
      color: #e5e7eb;
      box-shadow: 0 6px 16px rgba(0,0,0,0.55);
    }

    .btn-secondary:hover {
      background: #0f172a;
    }

    .status {
      margin-top: 8px;
      font-size: 12px;
      color: #9ca3af;
    }

    #download {
      margin-top: 8px;
      font-size: 13px;
    }

    canvas {
      background: #808080;
      border-radius: 18px;
      border: 1px solid #4b5563;
      box-shadow: 0 20px 40px rgba(0,0,0,0.8);
      max-height: 92vh;
      max-width: 100%;
    }

    @media (max-width: 900px) {
      body {
        flex-direction: column;
        padding: 10px;
      }

      .left,
      .right {
        width: 100%;
      }

      .right {
        margin-top: 10px;
      }

      textarea {
        font-size: 16px;
      }

      #body {
        min-height: 180px;
      }

      .panel {
        padding: 14px 12px;
      }
    }

    @media (max-width: 500px) {
      h2 {
        font-size: 16px;
      }

      small {
        font-size: 10px;
      }

      button {
        flex: 1 1 auto;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="panel left">
    <h2>Reels ‚Äì Upper / Judul / Subjudul / Isi</h2>
    <small>
      Judul: awalnya statis penuh (thumbnail aman), lalu hilang dan muncul lagi lewat wipe kiri‚Üíkanan (tanpa bar).<br>
      Isi memakai [[highlight]] per baris dengan animasi cepat dan ringan.
    </small>

    <div class="field">
      <label for="upper">Upper</label>
      <textarea id="upper" placeholder="Contoh: BREAKING NEWS / HEADLINE"></textarea>
    </div>

    <div class="field">
      <label for="title">Judul</label>
      <textarea id="title" placeholder="Judul utama yang akan tampil besar di awal video"></textarea>
    </div>

    <div class="field">
      <label for="subtitle">Subjudul</label>
      <textarea id="subtitle" placeholder="Subjudul singkat sebagai pelengkap judul"></textarea>
    </div>

    <div class="field">
      <label for="body">Isi</label>
      <textarea
        id="body"
        placeholder="Pisah halaman isi dengan satu baris kosong.&#10;Gunakan [[highlight]] untuk menandai frasa penting."
      ></textarea>
    </div>

    <div class="btn-row">
      <button class="btn-secondary" id="previewBtn">üëÅÔ∏è Preview</button>
      <button class="btn-primary" id="renderBtn">üé¨ Render (WEBM)</button>
    </div>
    <div class="status" id="status">Status: idle</div>
    <div id="download"></div>
  </div>

  <div class="panel right">
    <canvas id="canvas" width="1080" height="1920"></canvas>
  </div>

<script>
/* ============================================================
   BASE SETUP
   ============================================================ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const ua = navigator.userAgent;
const isMobile = /Android|iPhone|iPad|iPod/i.test(ua);

const LOGICAL_WIDTH = 1080;
const LOGICAL_HEIGHT = 1920;
/* SCALE: mobile dibuat lebih ringan agar animasi halus */
const SCALE = isMobile ? 0.75 : 1.5;

canvas.width  = LOGICAL_WIDTH * SCALE;
canvas.height = LOGICAL_HEIGHT * SCALE;
ctx.scale(SCALE, SCALE);

const upperEl = document.getElementById('upper');
const titleEl = document.getElementById('title');
const subtitleEl = document.getElementById('subtitle');
const bodyEl = document.getElementById('body');

const previewBtn = document.getElementById('previewBtn');
const renderBtn = document.getElementById('renderBtn');
const statusEl = document.getElementById('status');
const downloadEl = document.getElementById('download');

let animating = false;
let recording = false;
let mediaRecorder = null;
let recordedChunks = [];
let animStart = null;
let targetDuration = 12;

let bodyPages = [];
let pageDurations = [];

/* ====== TITLE LAYOUT & OFFSCREEN CANVAS ====== */
let titleLayout = {
  marginLeft: 110,
  marginRight: 140,
  textWidth: LOGICAL_WIDTH - 110 - 140,
  upperLines: [],
  titleLines: [],
  subtitleLines: []
};

let titleCanvas = null;
let titleCtx = null;
let titleTextureReady = false;

/* ============================================================
   TIMING
   ============================================================ */
const TITLE_PRE_HOLD = 0.3;   // judul statis penuh (thumbnail)
const TITLE_WIPE     = 0.8;   // durasi wipe
const TITLE_STATIC   = 2.0;   // setelah wipe, judul penuh lagi

const BODY_FADE_IN   = 0.3;
const BODY_WIPE      = 0.4;
const HIGHLIGHT_LINE_DUR = 0.8;
const PAGE_GAP = 0.6;

// Kecepatan baca kira-kira 3 kata / detik (180 kata per menit)
const READING_WORDS_PER_SEC = 3.0;

function setStatus(t) {
  statusEl.textContent = 'Status: ' + t;
}

/* ============================================================
   TEXT WRAP / TOKENS
   ============================================================ */
function wrapText(text, maxWidth, fontSpec) {
  if (fontSpec) ctx.font = fontSpec;

  const paragraphs = text.split(/\r?\n/);
  const lines = [];

  for (const para of paragraphs) {
    const trimmed = para.trim();
    if (!trimmed) {
      lines.push('');
      continue;
    }

    const words = trimmed.split(/\s+/);
    let line = words[0];

    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const testLine = line + ' ' + word;
      if (ctx.measureText(testLine).width > maxWidth) {
        lines.push(line);
        line = word;
      } else {
        line = testLine;
      }
    }
    lines.push(line);
  }

  return lines;
}

function tokenizeHighlighted(text) {
  let tokens = [];
  let buf = '';
  let hi = false;
  let i = 0;

  function flush() {
    if (buf.length > 0) {
      tokens.push({ text: buf, highlight: hi });
      buf = '';
    }
  }

  while (i < text.length) {
    if (!hi && text.startsWith('[[', i)) {
      flush();
      hi = true;
      i += 2;
    } else if (hi && text.startsWith(']]', i)) {
      flush();
      hi = false;
      i += 2;
    } else {
      const ch = text[i];
      buf += ch;
      if (ch === ' ') flush();
      i++;
    }
  }
  flush();
  return tokens;
}

/* ============================================================
   HIGHLIGHT ISI
   ============================================================ */
function drawLineFromTokens(tokens, x, y, normalColor, highlightBg, progress) {
  if (progress <= 0) {
    ctx.fillStyle = normalColor;
    ctx.fillText(tokens.map(t => t.text).join(''), x, y);
    return;
  }
  if (progress > 1) progress = 1;

  const full = tokens.map(t => t.text).join('');

  let first = null;
  let last = null;
  let index = 0;

  for (const t of tokens) {
    const len = t.text.length;
    if (t.highlight && t.text.trim().length > 0) {
      if (first === null) first = index;
      last = index + len;
    }
    index += len;
  }

  if (first !== null) {
    const before = full.slice(0, first);
    const inside = full.slice(first, last);

    const wBefore = ctx.measureText(before).width;
    const wInside = ctx.measureText(inside).width;
    const visible = wInside * progress;

    ctx.fillStyle = highlightBg;
    // disesuaikan untuk font 54px
    ctx.fillRect(x + wBefore - 4, y - 42, visible + 8, 54);
  }

  ctx.fillStyle = normalColor;
  ctx.fillText(full, x, y);
}

function drawWrappedRichParagraph(text, x, yStart, maxWidth, lineGap, normal, highlightBg, indexStart, time) {
  const tokens = tokenizeHighlighted(text);
  let lines = [];
  let curTokens = [];
  let curText = '';

  for (const tok of tokens) {
    const test = curText + tok.text;
    if (curText && ctx.measureText(test).width > maxWidth) {
      lines.push(curTokens);
      curTokens = [tok];
      curText = tok.text;
    } else {
      curTokens.push(tok);
      curText = test;
    }
  }
  if (curTokens.length) lines.push(curTokens);

  let y = yStart;
  let id = indexStart;

  for (const lineTokens of lines) {
    const startT = id * HIGHLIGHT_LINE_DUR;
    const rel = (time - startT) / HIGHLIGHT_LINE_DUR;
    const p = Math.max(0, Math.min(rel, 1));

    drawLineFromTokens(lineTokens, x, y, normal, highlightBg, p);
    y += lineGap;
    id++;
  }

  return { y, linesUsed: lines.length };
}

/* ============================================================
   BACKGROUND
   ============================================================ */
function drawBaseBackground() {
  ctx.fillStyle = '#808080';
  ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
}

/* ============================================================
   TITLE LAYOUT & OFFSCREEN RENDER
   ============================================================ */
function rebuildTitleLayout() {
  const marginLeft = 110;
  const marginRight = 140;
  const textWidth = LOGICAL_WIDTH - marginLeft - marginRight;

  const upper = upperEl.value.trim();
  const title = titleEl.value.trim();
  const subtitle = subtitleEl.value.trim();

  const upperFont    = "700 34px 'PlusJakartaCustom'";
  const titleFont    = "700 90px 'DMSerifCustomBold'";
  const subtitleFont = "700 34px 'PlusJakartaCustom'";

  let upperLines = [];
  let titleLines = [];
  let subtitleLines = [];

  if (upper) {
    upperLines = wrapText(upper, textWidth, upperFont);
  }
  if (title) {
    titleLines = wrapText(title, textWidth, titleFont);
  }
  if (subtitle) {
    subtitleLines = wrapText(subtitle, textWidth, subtitleFont);
  }

  titleLayout = {
    marginLeft,
    marginRight,
    textWidth,
    upperLines,
    titleLines,
    subtitleLines
  };

  rebuildTitleTexture();
}

function rebuildTitleTexture() {
  titleCanvas = document.createElement('canvas');
  titleCanvas.width = LOGICAL_WIDTH;
  titleCanvas.height = LOGICAL_HEIGHT;
  titleCtx = titleCanvas.getContext('2d');

  titleCtx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
  titleCtx.fillStyle = '#ffffff';
  titleCtx.textAlign = 'left';

  const marginLeft = titleLayout.marginLeft;
  const upperLines = titleLayout.upperLines;
  const titleLines = titleLayout.titleLines;
  const subtitleLines = titleLayout.subtitleLines;

  let y = LOGICAL_HEIGHT - 700;

  if (upperLines.length > 0) {
    titleCtx.font = "700 34px 'PlusJakartaCustom'";
    for (const line of upperLines) {
      titleCtx.fillText(line, marginLeft, y);
      y += 36;
    }
    y += 70;
  }

  if (titleLines.length > 0) {
    titleCtx.font = "700 90px 'DMSerifCustomBold'";
    for (const line of titleLines) {
      titleCtx.fillText(line, marginLeft, y);
      y += 90;
    }
    y -= 20;
  }

  if (subtitleLines.length > 0) {
    titleCtx.font = "700 34px 'PlusJakartaCustom'";
    for (const line of subtitleLines) {
      titleCtx.fillText(line, marginLeft, y);
      y += 36;
    }
  }

  titleTextureReady = true;
}

/* ============================================================
   TITLE SCENE (WIPE TANPA clip() BERAT)
   ============================================================ */
function drawTitleScene(t) {
  drawBaseBackground();

  const marginLeft = titleLayout.marginLeft;
  const textWidth  = titleLayout.textWidth;

  if (!titleTextureReady || !titleCanvas) {
    return;
  }

  // fase statis penuh (thumbnail)
  if (t < TITLE_PRE_HOLD) {
    ctx.drawImage(titleCanvas, 0, 0);
    return;
  }

  const localT = t - TITLE_PRE_HOLD;

  // fase wipe kiri‚Üíkanan
  if (localT < TITLE_WIPE) {
    let raw = localT / TITLE_WIPE;
    if (raw < 0) raw = 0;
    if (raw > 1) raw = 1;

    // sedikit ‚Äúboost‚Äù untuk smoothing di mobile
    if (isMobile) {
      raw = Math.min(1, raw + 0.012);
    }

    // smoothstep easing
    const p = raw * raw * (3 - 2 * raw);
    const clipWidth = marginLeft + textWidth * p;

    // gambar judul penuh dulu
    ctx.drawImage(titleCanvas, 0, 0);

    // kemudian tutup sisi kanan dengan background
    ctx.fillStyle = '#808080';
    ctx.fillRect(clipWidth, 0, LOGICAL_WIDTH - clipWidth, LOGICAL_HEIGHT);

    return;
  }

  // setelah wipe selesai: tampil penuh lagi
  ctx.drawImage(titleCanvas, 0, 0);
}

/* ============================================================
   ORPHAN FIX
   ============================================================ */
function fixOrphans(line) {
  line = line.replace(/\b(ke|di)\s+(?=\S)/gi, (m, p) => p + '\u00A0');
  line = line.replace(/\b(terima)\s+(kasih)\b/gi, 'terima\u00A0kasih');
  line = line.replace(/\b(Jawa)\s+(Pos)\b/gi, 'Jawa\u00A0Pos');
  return line;
}

/* ============================================================
   ESTIMASI BARIS (UNTUK ANCHOR & DURASI)
   ============================================================ */
function estimateLinesForParagraph(text, maxWidth) {
  // gunakan font isi 54px saat mengukur
  ctx.font = "700 54px 'PlusJakartaCustom'";

  const tokens = tokenizeHighlighted(text);
  let lines = 0;
  let curTokens = [];
  let curText = '';

  for (const tok of tokens) {
    const test = curText + tok.text;
    if (curText && ctx.measureText(test).width > maxWidth) {
      lines++;
      curTokens = [tok];
      curText = tok.text;
    } else {
      curTokens.push(tok);
      curText = test;
    }
  }
  if (curTokens.length) lines++;
  if (lines === 0) lines = 1;
  return lines;
}

/* ============================================================
   BODY PAGES ‚Äì BARIS KOSONG = HALAMAN BARU
   ============================================================ */
function rebuildBodyPages() {
  const raw = bodyEl.value.split("\n");
  bodyPages = [];
  let cur = [];

  for (const line of raw) {
    const tr = line.trimEnd();
    if (!tr.trim()) {
      if (cur.length > 0) {
        bodyPages.push(cur.slice());
        cur = [];
      }
    } else {
      cur.push(fixOrphans(tr));
    }
  }
  if (cur.length > 0) bodyPages.push(cur);
  if (bodyPages.length === 0) bodyPages = [[]];
}

/* ============================================================
   DRAW BODY PAGE ‚Äì ANCHOR BAWAH (IDEAL 7 BARIS)
   ============================================================ */
function drawBodyPage(pageIndex, t) {
  drawBaseBackground();

  const lines = bodyPages[pageIndex] || [];
  const W = LOGICAL_WIDTH;
  const marginLeft = 110;
  const marginRight = 140;
  const maxWidth = W - marginLeft - marginRight;

  let alpha = 1;
  if (t < BODY_FADE_IN) alpha = t / BODY_FADE_IN;

  let wipe = 1;
  if (t < BODY_WIPE) wipe = t / BODY_WIPE;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.rect(0, 0, marginLeft + maxWidth * wipe, LOGICAL_HEIGHT);
  ctx.clip();

  ctx.textAlign = 'left';
  // font isi 54px
  ctx.font = "700 54px 'PlusJakartaCustom'";

  // hitung total "unit baris" setelah wrap
  let totalUnits = 0;
  for (const raw of lines) {
    if (!raw.trim()) continue;
    totalUnits += estimateLinesForParagraph(raw, maxWidth);
  }

  const gap = 64;

  // posisi ideal untuk 7 baris (layout lama)
  const baseY = LOGICAL_HEIGHT - 600; // 1920 - 600 = 1320

  let y;

  if (totalUnits <= 7) {
    // isi pendek: pakai posisi lama apa adanya
    y = baseY;
  } else if (totalUnits <= 12) {
    // isi 8‚Äì12 baris: anchor di bawah
    // yStart = baseY + (7 - totalUnits) * gap
    y = baseY + (7 - totalUnits) * gap;
  } else {
    // >12 baris: treat sebagai 12 baris (disarankan pecah halaman)
    y = baseY + (7 - 12) * gap;
  }

  let idx = 0;

  for (const raw of lines) {
    if (!raw.trim()) {
      y += gap * 0.6;
      continue;
    }
    const res = drawWrappedRichParagraph(
      raw,
      marginLeft,
      y,
      maxWidth,
      gap,
      "#fff",
      "#0088d8",
      idx,
      t
    );
    y = res.y;
    idx += res.linesUsed;
  }

  ctx.restore();
}

/* ============================================================
   DURASI ‚Äì BERDASARKAN WAKTU BACA
   ============================================================ */
function recomputeTargetDuration() {
  rebuildTitleLayout();
  rebuildBodyPages();

  pageDurations = [];

  // pastikan font sama seperti saat draw isi
  ctx.font = "700 54px 'PlusJakartaCustom'";

  for (const page of bodyPages) {
    const joined = page.join(' ').trim();
    const words = joined ? joined.split(/\s+/).length : 0;

    if (words === 0) {
      // halaman kosong / sangat pendek
      pageDurations.push(3);
      continue;
    }

    const W = LOGICAL_WIDTH;
    const marginLeft = 110;
    const marginRight = 140;
    const maxWidth = W - marginLeft - marginRight;

    let totalUnits = 0;
    for (const raw of page) {
      if (!raw.trim()) continue;
      totalUnits += estimateLinesForParagraph(raw, maxWidth);
    }
    if (totalUnits === 0) totalUnits = 1;

    // durasi baca murni (detik) ‚âà jumlah kata / kata per detik
    const readingSeconds = words / READING_WORDS_PER_SEC;

    // durasi minimum supaya semua highlight sempat animasi
    const animMinimum = totalUnits * HIGHLIGHT_LINE_DUR + 0.5;

    // ambil yang paling besar, lalu clamp
    let d = Math.max(readingSeconds, animMinimum);

    if (d < 3) d = 3;    // minimal 3 detik per halaman
    if (d > 12) d = 12;  // maksimal ~12 detik per halaman

    pageDurations.push(d);
  }

  const titleTotal = TITLE_PRE_HOLD + TITLE_WIPE + TITLE_STATIC;
  const contentDurNoGap = pageDurations.reduce((a, b) => a + b, 0);
  const gapDur = PAGE_GAP * (bodyPages.length - 1);

  // TANPA BATAS HP/LAPTOP: semua judul + semua isi + jeda
  targetDuration = titleTotal + 1 + (contentDurNoGap + gapDur);
}

/* ============================================================
   FRAME SELECTOR
   ============================================================ */
function drawFrame(globalT) {
  const titleTotal = TITLE_PRE_HOLD + TITLE_WIPE + TITLE_STATIC;
  const afterTitleGap = titleTotal + 1;

  if (globalT <= titleTotal) {
    drawTitleScene(globalT);
    return;
  }

  if (globalT <= afterTitleGap) {
    drawBaseBackground();
    return;
  }

  const tBody = globalT - afterTitleGap;
  let acc = 0;

  for (let i = 0; i < bodyPages.length; i++) {
    const d = pageDurations[i];
    if (tBody < acc + d) {
      drawBodyPage(i, tBody - acc);
      return;
    }
    if (tBody < acc + d + PAGE_GAP) {
      drawBaseBackground();
      return;
    }
    acc += d + PAGE_GAP;
  }

  const lastIndex = bodyPages.length - 1;
  const lastDur = pageDurations[lastIndex] || 1;
  drawBodyPage(lastIndex, lastDur);
}

/* ============================================================
   ANIM LOOP
   ============================================================ */
function animate(ts) {
  if (!animating && !recording) return;
  if (!animStart) animStart = ts;

  const elapsed = (ts - animStart) / 1000;
  drawFrame(Math.min(elapsed, targetDuration));

  if (elapsed < targetDuration) {
    requestAnimationFrame(animate);
  } else if (!recording) {
    animating = false;
    setStatus("preview selesai");
  }
}

/* ============================================================
   PREVIEW
   ============================================================ */
previewBtn.addEventListener("click", () => {
  recomputeTargetDuration();
  animStart = null;
  animating = true;
  recording = false;
  setStatus("preview");
  requestAnimationFrame(animate);
});

/* ============================================================
   MEDIARECORDER FALLBACK (VP9 default -> VP8 fallback)
   Layout tidak berubah, hanya pemilihan codec.
   ============================================================ */
function pickBestRecorder(stream) {
  const candidates = [
    "video/webm;codecs=vp9", // default
    "video/webm;codecs=vp8", // fallback
    "video/webm",
    "" // let browser decide
  ];

  let lastError = null;

  for (const mime of candidates) {
    if (mime && !MediaRecorder.isTypeSupported(mime)) continue;

    try {
      const opts = mime ? { mimeType: mime } : {};
      // test cepat: beberapa device error saat start()
      const test = new MediaRecorder(stream, opts);
      try {
        test.start(30);
        test.stop();
      } catch (e) {
        lastError = e;
        continue;
      }

      // buat recorder final
      return { recorder: new MediaRecorder(stream, opts), mime };
    } catch (e) {
      lastError = e;
      continue;
    }
  }

  throw lastError || new Error("Tidak ada codec MediaRecorder yang kompatibel.");
}

/* ============================================================
   RENDER (WEBM)
   ============================================================ */
renderBtn.addEventListener("click", () => {
  if (typeof MediaRecorder === "undefined") {
    alert("MediaRecorder tidak tersedia di perangkat ini.");
    setStatus("MediaRecorder tidak didukung");
    return;
  }

  if (typeof canvas.captureStream !== "function") {
    alert("Browser ini tidak mendukung perekaman langsung dari canvas.\n\nCoba gunakan Chrome/Edge/Brave di Android atau render dari laptop/PC.");
    setStatus("captureStream tidak didukung di browser ini");
    return;
  }

  recomputeTargetDuration();

  const FPS = isMobile ? 24 : 30;
  const stream = canvas.captureStream(FPS);
  recordedChunks = [];

  let chosenMime = "";
  try {
    const res = pickBestRecorder(stream);
    mediaRecorder = res.recorder;
    chosenMime = res.mime || "";
  } catch (err) {
    alert("Perangkat ini tidak mendukung perekaman video WebM (VP9/VP8).\n" + err);
    setStatus("Format video tidak didukung");
    return;
  }

  mediaRecorder.ondataavailable = (e) => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };

  mediaRecorder.onstop = () => {
    if (recordedChunks.length === 0) {
      alert("Tidak ada data rekaman video (fitur mungkin dibatasi di perangkat ini).");
      setStatus("Tidak ada data video");
      recording = false;
      return;
    }

    const blob = new Blob(recordedChunks, { type: "video/webm" });
    const url = URL.createObjectURL(blob);

    let label = "webm";
    if (chosenMime.includes("vp9")) label = "vp9";
    else if (chosenMime.includes("vp8")) label = "vp8";

    const a = document.createElement("a");
    a.href = url;
    a.download = `reels_output_${label}.webm`;
    a.textContent = `Download video (WEBM ${label.toUpperCase()})`;
    a.style.color = "#38bdf8";
    a.style.textDecoration = "underline";

    downloadEl.innerHTML = "";
    downloadEl.appendChild(a);

    setStatus("render selesai");
    recording = false;
  };

  recording = true;
  animating = true;
  animStart = null;
  setStatus("rendering...");
  requestAnimationFrame(animate);

  setTimeout(() => {
    if (!mediaRecorder) return;
    try {
      mediaRecorder.start();
    } catch (e) {
      console.error("MediaRecorder.start error:", e);
      alert("Gagal memulai perekaman di perangkat ini.");
      setStatus("Gagal memulai perekaman");
      recording = false;
      animating = false;
      return;
    }
  }, 120);

  setTimeout(() => {
    if (recording && mediaRecorder && mediaRecorder.state === "recording") {
      mediaRecorder.stop();
    }
  }, targetDuration * 1000 + 500);
});

/* ============================================================
   INITIAL FRAME
   ============================================================ */
if (document.fonts && document.fonts.ready) {
  document.fonts.ready.then(() => {
    rebuildTitleLayout();
    drawFrame(0);
  });
} else {
  rebuildTitleLayout();
  drawFrame(0);
}
</script>
</body>
</html>
