<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Reels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    /* CSS ASLI ANDA - TIDAK ADA PERUBAHAN */
    * { box-sizing: border-box; }
    @font-face {
      font-family: 'DMSerifCustomBold';
      src: url('./fonts/DMSerifDisplay-Bold.ttf') format('truetype');
      font-weight: 700; font-style: normal; font-display: swap;
    }
    @font-face {
      font-family: 'PlusJakartaCustom';
      src: url('./fonts/PlusJakartaSans-Bold.woff2') format('woff2');
      font-weight: 700; font-style: normal; font-display: swap;
    }
    body {
      margin: 0; padding: 12px; display: flex; gap: 16px;
      background: radial-gradient(circle at top, #020617 0%, #020617 40%, #020617 100%);
      color: #e5e7eb;
      font-family: 'PlusJakartaCustom', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    .panel { background: #020617; padding: 16px 14px; border-radius: 14px; border: 1px solid #1f2937; box-shadow: 0 16px 40px rgba(0,0,0,0.65); }
    .left { width: 380px; max-width: 100%; flex-shrink: 0; }
    .right { flex: 1; display: flex; justify-content: center; align-items: center; min-width: 0; }
    h2 { margin: 0 0 4px 0; font-size: 18px; letter-spacing: 0.02em; }
    small { font-size: 11px; color: #9ca3af; display: block; margin-bottom: 6px; line-height: 1.4; }
    .field { margin-top: 10px; }
    label { font-size: 13px; display: block; margin-bottom: 4px; color: #cbd5f5; }
    textarea { width: 100%; min-height: 56px; background: #020617; color: #e5e7eb; border-radius: 10px; border: 1px solid #334155; padding: 9px 11px; font-size: 14px; line-height: 1.5; resize: vertical; outline: none; }
    #body { min-height: 130px; }
    .btn-row { margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap; }
    button { padding: 8px 16px; border-radius: 999px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; display: inline-flex; align-items: center; gap: 6px; }
    .btn-primary { background: #2563eb; color: #fff; }
    .btn-secondary { background: #111827; color: #e5e7eb; }
    .status { margin-top: 8px; font-size: 12px; color: #9ca3af; }
    canvas { background: #808080; border-radius: 18px; border: 1px solid #4b5563; max-height: 92vh; max-width: 100%; }
  </style>
</head>
<body>
  <div class="panel left">
    <h2>Reels Editor</h2>
    <div class="field"><label>Upper</label><textarea id="upper"></textarea></div>
    <div class="field"><label>Judul</label><textarea id="title"></textarea></div>
    <div class="field"><label>Subjudul</label><textarea id="subtitle"></textarea></div>
    <div class="field"><label>Isi</label><textarea id="body"></textarea></div>
    <div class="btn-row">
      <button class="btn-secondary" id="previewBtn">üëÅÔ∏è Preview</button>
      <button class="btn-primary" id="renderBtn">üé¨ Render (WEBM)</button>
    </div>
    <div class="status" id="status">Status: idle</div>
    <div id="download"></div>
  </div>

  <div class="panel right">
    <canvas id="canvas" width="1080" height="1920"></canvas>
  </div>

<script>
/* ============================================================
   BASE SETUP - ASLI DARI KODE ANDA
   ============================================================ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const LOGICAL_WIDTH = 1080;
const LOGICAL_HEIGHT = 1920;
const SCALE = 1.5; 

canvas.width  = LOGICAL_WIDTH * SCALE;
canvas.height = LOGICAL_HEIGHT * SCALE;
ctx.scale(SCALE, SCALE);

const upperEl = document.getElementById('upper');
const titleEl = document.getElementById('title');
const subtitleEl = document.getElementById('subtitle');
const bodyEl = document.getElementById('body');
const previewBtn = document.getElementById('previewBtn');
const renderBtn = document.getElementById('renderBtn');
const statusEl = document.getElementById('status');
const downloadEl = document.getElementById('download');

let animating = false, recording = false, animStart = null;
let targetDuration = 12, bodyPages = [], pageDurations = [];
let titleCanvas = null, titleTextureReady = false;

let titleLayout = { marginLeft: 110, marginRight: 140, textWidth: 830, upperLines: [], titleLines: [], subtitleLines: [] };

/* TIMING ASLI ANDA */
const TITLE_PRE_HOLD = 0.3;   
const TITLE_WIPE     = 0.8;   
const TITLE_STATIC   = 2.0;   
const BODY_FADE_IN   = 0.3;
const BODY_WIPE      = 0.4;
const HIGHLIGHT_LINE_DUR = 0.8;
const PAGE_GAP       = 0.6;
const READING_WORDS_PER_SEC = 3.0;

function setStatus(t) { statusEl.textContent = 'Status: ' + t; }

/* FUNGSI WRAP & TOKEN ASLI ANDA */
function wrapText(text, maxWidth, fontSpec) {
  if (fontSpec) ctx.font = fontSpec;
  const paragraphs = text.split(/\r?\n/);
  const lines = [];
  for (const para of paragraphs) {
    const trimmed = para.trim();
    if (!trimmed) { lines.push(''); continue; }
    const words = trimmed.split(/\s+/);
    let line = words[0];
    for (let i = 1; i < words.length; i++) {
      if (ctx.measureText(line + ' ' + words[i]).width > maxWidth) {
        lines.push(line); line = words[i];
      } else { line += ' ' + words[i]; }
    }
    lines.push(line);
  }
  return lines;
}

function tokenizeHighlighted(text) {
  let tokens = [], buf = '', hi = false, i = 0;
  function flush() { if (buf.length > 0) { tokens.push({ text: buf, highlight: hi }); buf = ''; } }
  while (i < text.length) {
    if (!hi && text.startsWith('[[', i)) { flush(); hi = true; i += 2; }
    else if (hi && text.startsWith(']]', i)) { flush(); hi = false; i += 2; }
    else { let ch = text[i]; buf += ch; if (ch === ' ') flush(); i++; }
  }
  flush(); return tokens;
}

/* MODIFIKASI: Menambahkan parameter clipHigh khusus untuk highlight */
function drawLineFromTokens(tokens, x, y, normalColor, highlightBg, progress, clipHigh) {
  const full = tokens.map(t => t.text).join('');
  let index = 0, first = null, last = null;
  for (const t of tokens) {
    if (t.highlight && t.text.trim().length > 0) {
      if (first === null) first = index;
      last = index + t.text.length;
    }
    index += t.text.length;
  }
  if (first !== null) {
    ctx.save();
    // Gunakan clipHigh (yang ada delay) khusus untuk kotak highlight
    ctx.beginPath(); ctx.rect(0, 0, clipHigh, LOGICAL_HEIGHT); ctx.clip();
    const before = full.slice(0, first);
    const inside = full.slice(first, last);
    const wBefore = ctx.measureText(before).width;
    const wInside = ctx.measureText(inside).width;
    const visible = wInside * progress;
    ctx.fillStyle = highlightBg;
    ctx.fillRect(x + wBefore - 4, y - 42, visible + 8, 54);
    ctx.restore();
  }
  ctx.fillStyle = normalColor;
  ctx.fillText(full, x, y);
}

function drawWrappedRichParagraph(text, x, yStart, maxWidth, lineGap, normal, highlightBg, indexStart, time, clipHigh) {
  const tokens = tokenizeHighlighted(text);
  let lines = [], curTokens = [], curText = '';
  for (const tok of tokens) {
    if (curText && ctx.measureText(curText + tok.text).width > maxWidth) {
      lines.push(curTokens); curTokens = [tok]; curText = tok.text;
    } else { curTokens.push(tok); curText += tok.text; }
  }
  if (curTokens.length) lines.push(curTokens);
  let y = yStart; let id = indexStart;
  for (const lineTokens of lines) {
    const startT = id * HIGHLIGHT_LINE_DUR;
    const p = Math.max(0, Math.min((time - startT) / HIGHLIGHT_LINE_DUR, 1));
    drawLineFromTokens(lineTokens, x, y, normal, highlightBg, p, clipHigh);
    y += lineGap; id++;
  }
  return { y, linesUsed: lines.length };
}

/* FUNGSI TITLE ASLI ANDA */
function rebuildTitleLayout() {
  const textWidth = 830;
  titleLayout.upperLines = wrapText(upperEl.value.trim(), textWidth, "700 34px 'PlusJakartaCustom'");
  titleLayout.titleLines = wrapText(titleEl.value.trim(), textWidth, "700 90px 'DMSerifCustomBold'");
  titleLayout.subtitleLines = wrapText(subtitleEl.value.trim(), textWidth, "700 34px 'PlusJakartaCustom'");
  rebuildTitleTexture();
}

function rebuildTitleTexture() {
  titleCanvas = document.createElement('canvas');
  titleCanvas.width = 1080; titleCanvas.height = 1920;
  const tCtx = titleCanvas.getContext('2d');
  tCtx.fillStyle = '#ffffff'; tCtx.textAlign = 'left';
  let y = 1220;
  tCtx.font = "700 34px 'PlusJakartaCustom'";
  titleLayout.upperLines.forEach(l => { tCtx.fillText(l, 110, y); y += 36; });
  y += 70;
  tCtx.font = "700 90px 'DMSerifCustomBold'";
  titleLayout.titleLines.forEach(l => { tCtx.fillText(l, 110, y); y += 90; });
  y -= 20;
  tCtx.font = "700 34px 'PlusJakartaCustom'";
  titleLayout.subtitleLines.forEach(l => { tCtx.fillText(l, 110, y); y += 36; });
  titleTextureReady = true;
}

function drawTitleScene(t) {
  ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 1080, 1920);
  if (t < TITLE_PRE_HOLD) { ctx.drawImage(titleCanvas, 0, 0); return; }
  const localT = t - TITLE_PRE_HOLD;
  const p = Math.min(1, localT / TITLE_WIPE);
  const clipWidth = 110 + 830 * (p * p * (3 - 2 * p));
  ctx.drawImage(titleCanvas, 0, 0);
  ctx.fillStyle = '#808080';
  ctx.fillRect(clipWidth, 0, 1080 - clipWidth, 1920);
}

function rebuildBodyPages() {
  const raw = bodyEl.value.split("\n");
  bodyPages = []; let cur = [];
  for (const line of raw) {
    if (!line.trim()) { if (cur.length > 0) bodyPages.push(cur); cur = []; }
    else { cur.push(line); }
  }
  if (cur.length > 0) bodyPages.push(cur);
}

function estimateLinesForParagraph(text, maxWidth) {
  ctx.font = "700 54px 'PlusJakartaCustom'";
  const tokens = tokenizeHighlighted(text);
  let lines = 0, curText = '';
  for (const tok of tokens) {
    if (curText && ctx.measureText(curText + tok.text).width > maxWidth) { lines++; curText = tok.text; }
    else curText += tok.text;
  }
  return lines + 1;
}

/* PERBAIKAN: Animasi Sapuan Teks & Highlight dengan Delay */
function drawBodyPage(pageIndex, t) {
  ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 1080, 1920);
  const lines = bodyPages[pageIndex] || [];
  const margin = 110, textWidth = 830;

  // 1. Clip Teks Utama (Normal)
  let wipe = Math.min(1, t / BODY_WIPE);
  const clipText = margin + textWidth * (wipe * wipe * (3 - 2 * wipe));

  // 2. Clip Highlight (Diberi Delay 0.2 detik)
  const delay = 0.2;
  let wipeHigh = Math.max(0, Math.min(1, (t - delay) / BODY_WIPE));
  const clipHigh = margin + textWidth * (wipeHigh * wipeHigh * (3 - 2 * wipeHigh));

  ctx.save();
  ctx.globalAlpha = Math.min(1, t / BODY_FADE_IN);
  ctx.beginPath(); ctx.rect(0, 0, clipText, 1920); ctx.clip(); // Teks di-wipe normal
  
  ctx.font = "700 54px 'PlusJakartaCustom'"; ctx.textAlign = 'left';
  let totalUnits = 0; lines.forEach(l => totalUnits += estimateLinesForParagraph(l, textWidth));
  const gap = 64; let y = 1320 + (7 - Math.min(totalUnits, 12)) * (gap/2);
  let idx = 0;
  for (const raw of lines) {
    const res = drawWrappedRichParagraph(raw, margin, y, textWidth, gap, "#fff", "#0088d8", idx, t, clipHigh);
    y = res.y; idx += res.linesUsed;
  }
  ctx.restore();
}

function recomputeTargetDuration() {
  rebuildTitleLayout(); rebuildBodyPages();
  pageDurations = bodyPages.map(p => Math.max(3, p.join(' ').split(/\s+/).length / READING_WORDS_PER_SEC));
  const titleTotal = TITLE_PRE_HOLD + TITLE_WIPE + TITLE_STATIC;
  targetDuration = titleTotal + 1 + pageDurations.reduce((a, b) => a + b, 0) + (PAGE_GAP * (bodyPages.length - 1));
}

function drawFrame(globalT) {
  const titleTotal = TITLE_PRE_HOLD + TITLE_WIPE + TITLE_STATIC;
  if (globalT <= titleTotal) { drawTitleScene(globalT); return; }
  if (globalT <= titleTotal + 1) { ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, 1080, 1920); return; }
  const tBody = globalT - (titleTotal + 1);
  let acc = 0;
  for (let i = 0; i < bodyPages.length; i++) {
    const d = pageDurations[i];
    if (tBody < acc + d) { drawBodyPage(i, tBody - acc); return; }
    acc += d + PAGE_GAP;
  }
}

function animate(ts) {
  if (!animating && !recording) return;
  if (!animStart) animStart = ts;
  const elapsed = (ts - animStart) / 1000;
  drawFrame(Math.min(elapsed, targetDuration));
  if (elapsed < targetDuration) requestAnimationFrame(animate);
  else { animating = false; setStatus("idle"); }
}

previewBtn.onclick = () => { recomputeTargetDuration(); animStart = null; animating = true; requestAnimationFrame(animate); };
renderBtn.onclick = () => {
  recomputeTargetDuration();
  const stream = canvas.captureStream(30);
  const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  let chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob); a.download = `reels.webm`; a.click();
  };
  recorder.start(); animating = true; recording = true; animStart = null; requestAnimationFrame(animate);
  setTimeout(() => recorder.stop(), targetDuration * 1000 + 500);
};

rebuildTitleLayout(); drawFrame(0);
</script>
</body>
</html>
